package database

import (
	"context"
	"errors"
	"fmt"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"log"
	sharedconfig "service-shared/shared-config"
	sharedhelpers "service-shared/shared-helpers"
	sharedmodels "service-shared/shared-models"
	"time"
)

const (
	internalErrorResponse = "sorry, an internal system error occurred"
	timeout               = 15
)

var (
	ctx           = context.Background()
	InternalError = errors.New(internalErrorResponse)
)

//Repository presents an abstraction for working with a database repository.
//Any database satisfying this contract can be used to store loan applications.
type Repository interface {
	CreateApplication(firstName, lastName string) (string, error)
	GetApplication(applicationID string) (*sharedmodels.ApplicationEntry, error)
	GetApplicationsWithStatus(status sharedmodels.Status) ([]sharedmodels.ApplicationEntry, error)
	UpdateApplicationStatus(applicationID string, status sharedmodels.Status) error
	RemoveApplication(applicationID string) error
}

type MongoRepository struct {
	mongoCaller MongoCaller
}

func NewMongoRepository(mongoCaller MongoCaller) Repository {
	return &MongoRepository{mongoCaller: mongoCaller}
}

/*
CreateApplication creates an entry in the DB for a loan application
The objectID generated by mongo is made up of 12 bytes using the following scheme:
				- The first 4 bytes are a timestamp
				- The next 5 bytes are a random value generated once per process. It is unique to the machine AND process
				- The next 3 bytes are an incrementing counter, initialized to a random value.
This makes collisions here very unlikely, but still, we check and retry if it happens.
*/
func (mongoRepo MongoRepository) CreateApplication(firstName, lastName string) (string, error) {
	context, cancel := context.WithTimeout(ctx, timeout*time.Second)
	defer cancel()
	for {
		result, err := mongoRepo.mongoCaller.InsertOne(context, getApplicationEntry(firstName, lastName, sharedmodels.Pending))
		if err != nil {
			if mongo.IsDuplicateKeyError(err) {
				log.Println("Duplicate key error while creating new application. Retrying")
				continue
			}

			return "", InternalError
		}

		return result.InsertedID.(primitive.ObjectID).Hex(), nil
	}
}

/*
GetApplication retrieves an application entry from the database given its application ID.
The provided applicationID is expected to conform to the requirements of primitive.ObjectIDFromHex

In case of an unrecoverable DB error, returns InternalError.
*/
func (mongoRepo MongoRepository) GetApplication(applicationID string) (*sharedmodels.ApplicationEntry, error) {
	context, cancel := context.WithTimeout(ctx, timeout*time.Second)
	defer cancel()
	objID, err := primitive.ObjectIDFromHex(applicationID)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("The application_id %s does not exist", applicationID))
	}

	var dbEntry sharedmodels.ApplicationEntry
	findErr := mongoRepo.mongoCaller.FindOne(context, sharedmodels.ApplicationEntry{ID: objID}).Decode(&dbEntry)

	if findErr != nil {
		if errors.Is(findErr, mongo.ErrNoDocuments) {
			return nil, errors.New(fmt.Sprintf("The application_id %s does not exist", applicationID))
		}

		log.Printf("Unable to decode application ID for application_id %s the error was %s\n", applicationID, findErr.Error())
		return nil, InternalError
	}

	return &dbEntry, nil
}

/*
GetApplicationsWithStatus retrieves all applications matching a given status from the database.

In case of an unrecoverable DB error, returns InternalError.
*/
func (mongoRepo MongoRepository) GetApplicationsWithStatus(status sharedmodels.Status) ([]sharedmodels.ApplicationEntry, error) {
	context, cancel := context.WithTimeout(ctx, timeout*time.Second)
	defer cancel()
	cursor, err := mongoRepo.mongoCaller.Find(context, sharedmodels.ApplicationEntry{Status: status})
	if err != nil {
		log.Println(fmt.Sprintf("Unable to get applications with status %s - the error was %s", status, err))
		return nil, InternalError
	}

	var result []sharedmodels.ApplicationEntry
	if err = cursor.All(context, &result); err != nil {
		log.Printf("Encountered an error obtaining all applications with status %s - the error was %s\n", status, err)
		return nil, InternalError
	}

	return result, nil
}

/*
UpdateApplicationStatus updates the status of an application with the provided status string

In case of an unrecoverable error, returns InternalError.
*/
func (mongoRepo MongoRepository) UpdateApplicationStatus(applicationID string, status sharedmodels.Status) error {
	context, cancel := context.WithTimeout(ctx, timeout*time.Second)
	defer cancel()
	objID, _ := primitive.ObjectIDFromHex(applicationID)
	entry := sharedmodels.ApplicationEntry{ID: objID, Status: status}
	update := bson.M{
		"$set": entry,
	}

	_, err := mongoRepo.mongoCaller.UpdateByID(context, objID, update)
	if err != nil {
		log.Printf("Internal error updating application status : %s\n", err)
		return InternalError
	}

	return err
}

/*
RemoveApplication deletes an application from the database given its application ID.

In case of an unrecoverable error, returns InternalError.
*/
func (mongoRepo MongoRepository) RemoveApplication(applicationID string) error {
	context, cancel := context.WithTimeout(ctx, timeout*time.Second)
	defer cancel()
	primitiveID, _ := primitive.ObjectIDFromHex(applicationID)

	_, err := mongoRepo.mongoCaller.DeleteOne(context, bson.M{"_id": primitiveID})
	if err != nil {
		log.Printf("Internal error removing application : %s\n", err)
		return InternalError
	}
	return err
}

func getApplicationEntry(firstName, lastName string, status sharedmodels.Status) sharedmodels.ApplicationEntry {
	return sharedmodels.ApplicationEntry{
		Status:    status,
		FirstName: firstName,
		LastName:  lastName,
	}
}

//InitClient initialises a mongo client
func InitClient(cfg sharedconfig.Config) (*mongo.Client, error) {
	context, cancel := context.WithTimeout(ctx, timeout*time.Second)
	defer cancel()

	clientOptions := options.Client().ApplyURI(cfg.MongoURI)

	dbClient, err := mongo.Connect(context, clientOptions)
	if err != nil {
		return nil, err
	}

	// Check db connection
	err = dbClient.Ping(context, nil)
	if err != nil {
		return nil, err
	}

	return dbClient, nil
}

/*
InitIndexes sets up indexes on a mongo collection. Right now, this is intended
to be used in a single collection, that being the loan application collection.

It creates an index on the 'status' field to improve query performance when
attempting to query for all applications matching a provided status.
*/
func InitIndexes(collection *mongo.Collection) {
	context, cancel := context.WithTimeout(ctx, timeout*time.Second)
	defer cancel()

	model := mongo.IndexModel{
		Keys:    bson.D{{Key: "status", Value: 1}},
		Options: options.Index().SetUnique(false),
	}

	indexView := collection.Indexes()

	_, err := indexView.CreateOne(context, model)
	if err != nil {
		sharedhelpers.FailOnError(err, "Failed to initialise indexes")
	}
}
